# Ethereum Credit Guild Advanced analysis Report




## Introduction
The Ethereum Credit Guild is a DeFi protocol that encompasses a suite of smart contracts designed to manage credit issuance, governance, token economics, and various other financial operations. The protocol aims to create a decentralized ecosystem for credit and governance, leveraging blockchain technology to provide transparency, security, and community-driven decision-making.


## Analysis Contracts 

1 . Core.sol
2 . CoreRef.sol
3 . CoreRoles.sol
4 . GuildGovernor.sol
5 . GuildTimelockController.sol
6 . LendingTermOffboarding.sol
7 . LendingTermOnboarding.sol
8 . ProfitManager.sol
9 . GuildVetoGovernor.sol
10 . ERC20Gauges.sol
11 . ERC20MultiVotes.sol
12 . ERC20RebaseDistributor.sol
13 . CreditToken.sol
14 . GuildToken.sol
15 . AuctionHouse.sol
16 . LendingTerm.sol
17 . SimplePSM.sol
18 . SurplusGuildMinter.sol
19 . RateLimitedMinter.sol
20 . RateLimitedV2.sol



## Protocol Architecture 
 The Ethereum Credit Guild Protocol is a complex DeFi ecosystem designed to facilitate various operations such as credit issuance, governance, token management, and financial transactions. Here's a detailed explanation of how the protocol works, based on the functionality of each contract:


 **Core Access Control System**
- **Core.sol:** This contract is the heart of the protocol's access control system. It grants roles to different addresses, allowing them to perform specific actions within the protocol. For example, a CREDIT_MINTER role might be able to issue new credit tokens, while a GOVERNOR role might have the authority to change system parameters.
- **CoreRef.sol:** Likely a helper contract that provides a common interface for other contracts to interact with the Core contract, ensuring that access control checks are consistently applied across the protocol.
- **CoreRoles.sol:** This contract defines the various roles and their permissions within the protocol, ensuring that each role has specific capabilities and responsibilities.

 **Governance Mechanism**
- **GuildGovernor.sol:** This contract manages the governance process, allowing stakeholders to propose, debate, and vote on changes to the protocol. It ensures that changes to the protocol are made democratically and are in line with the community's interests.
- **GuildTimelockController.sol:** Works in conjunction with the governance contract to enforce a delay between the successful vote of a proposal and its execution. This delay allows for a period of review and potential intervention if necessary.
- **GuildVetoGovernor.sol:** Provides a specialized governance contract with the ability to veto decisions, adding an additional layer of oversight to prevent potentially harmful proposals from being executed.

 **Credit and Lending Operations**
- **LendingTerm.sol:** Defines the terms and conditions for lending operations within the guild, providing a standardized framework for credit issuance.
- **LendingTermOnboarding.sol & LendingTermOffboarding.sol:** These contracts manage the initiation and conclusion of lending agreements. The onboarding contract handles the creation of new lending terms, while the offboarding contract deals with the settlement or termination of loans.

**Financial Management**
- **ProfitManager.sol:** Responsible for managing the distribution of profits generated by the protocol's activities. It calculates the profits and distributes them to stakeholders according to predefined rules.
- **AuctionHouse.sol:** Facilitates auctions for assets or rights within the guild. This contract likely handles the bidding process, determines winners, and manages the transfer of assets.
- **SimplePSM.sol:** A Peg Stability Module that likely allows users to exchange assets at stable rates, potentially to maintain the value of a stablecoin or manage the guild's reserves.

**Token Management and Economics**
- **CreditToken.sol & GuildToken.sol:** These are the native tokens of the guild. The CreditToken might be used for credit issuance within the system, while the GuildToken could be used for governance and profit-sharing.
- **ERC20Gauges.sol & ERC20MultiVotes.sol:** Related to staking and voting, these contracts incentivize token holders to participate in governance by staking their tokens and possibly receiving multiple votes or other rewards.
- **ERC20RebaseDistributor.sol:** Manages the distribution of rebase rewards, which are adjustments made to token balances to account for inflationary or deflationary pressures.

**Minting and Token Supply Control**
- **SurplusGuildMinter.sol:** Mints new tokens from surplus profits, which could be a mechanism for profit-sharing among stakeholders or reinvestment into the guild.
- **RateLimitedMinter.sol & RateLimitedV2.sol:** These contracts impose limits on the rate of token minting to prevent inflation and maintain the value of the guild's tokens.







##  Contracts Mechanism Review 

### 1 . Core.sol

**Inheritance** 
-  The contract inherits from AccessControlEnumerable, which is an extension of OpenZeppelin's AccessControl contract. This provides a flexible and extendable framework for role-based permission management and also allows for enumeration of roles and account holders.

**Purpose** 
 - The primary purpose of the Core.sol contract is to manage access control by defining roles, granting permissions, and enforcing restrictions on who can perform certain actions within the system.

*Constructor*
- Upon deployment, the constructor grants the GOVERNOR role to the deploying address (presumably the initial system administrator or deployer).
- The constructor sets up a hierarchy of roles, all administered by the GOVERNOR role. This establishes a centralized control structure at the outset, where the GOVERNOR has the power to manage all other roles.

**Role Management**
- The contract defines a series of roles, each representing a set of permissions within the guild's ecosystem. These roles include GUARDIAN, CREDIT_MINTER, RATE_LIMITED_CREDIT_MINTER, GUILD_MINTER, RATE_LIMITED_GUILD_MINTER, and several others related to governance and operational parameters.
- Each role has an associated admin role, which is initially set to GOVERNOR. The admin role has the authority to grant or revoke the associated role.

**Role Administration Functions**
- createRole(bytes32 role, bytes32 adminRole): This function allows the GOVERNOR to create new roles or update the admin role of existing ones. This is a powerful function that can alter the access control hierarchy.

**Access Control Functions**
- The contract includes standard AccessControlEnumerable functions such as hasRole, getRoleAdmin, grantRole, revokeRole, and renounceRole.
These functions are used to check if an account has a certain role, get the admin role for a given role, grant or revoke roles to accounts, and allow an account to renounce a role it has been granted.

### 2 .  CoreRef.sol

**Inheritance**
-  The contract inherits from OpenZeppelin's Pausable contract, which provides mechanisms to pause and unpause contract functions, adding an extra layer of control and security.

**Core Contract Reference**
- It holds a private variable _core that stores the address of the Core contract. This reference is crucial for the contract to interact with the Core and check permissions.

**Constructor**
-  Upon deployment, the constructor sets the initial reference to the Core contract using the provided coreAddress.

**Role-Based Access Control (RBAC)**
-  The contract defines a modifier onlyCoreRole that checks if the msg.sender has a specific role in the Core contract before allowing execution of the modified function.

**Core Update Mechanism**
-  The setCore function allows updating the reference to the Core contract. This function is protected by the onlyCoreRole modifier, ensuring that only an address with the GOVERNOR role can change the core reference. An internal function _setCore performs the actual update and emits a CoreUpdate event to log the change.

**Pause Functionality**
-  The pause and unpause functions allow toggling the contract's operational state between paused and unpaused. These functions are also protected by the onlyCoreRole modifier, requiring the GUARDIAN role.

**Emergency Action**
-  The contract includes an emergencyAction function that allows the execution of arbitrary transactions, including sending ETH to other contracts. This function is intended for emergency situations and is restricted to the GOVERNOR role.

**Events**
-  The contract defines the CoreUpdate event to log changes to the core reference.


### 3 . CoreRoles.sol

Each role is represented by a bytes32 hash, which ensures uniqueness and security. These roles are used in access control mechanisms to restrict the execution of certain functions to addresses that have been granted specific roles.

Here's a concise overview of the roles:

- `GOVERNOR`: The most powerful role with overarching control over the protocol and the ability to manage all other roles.

- `GUARDIAN`: A role designed for emergency intervention, capable of pausing contracts and revoking roles.

- `CREDIT_MINTER`: Grants the ability to mint the CREDIT token without restrictions.

- `RATE_LIMITED_CREDIT_MINTER`: Allows minting of CREDIT tokens but with imposed rate limits and a maximum cap.

- `GUILD_MINTER`: Permits unrestricted minting of the GUILD token.

- `RATE_LIMITED_GUILD_MINTER`: Allows minting of GUILD tokens with rate limits and a cap.

- `GAUGE_ADD`: Authorizes the addition of new gauges, which are likely mechanisms for tracking and distributing rewards.

- `GAUGE_REMOVE`: Grants permission to remove existing gauges from the system.

- `GAUGE_PARAMETERS`: Enables the management of gauge-specific parameters, such as caps and limits.

- `GAUGE_PNL_NOTIFIER`: Allows for the notification of profit and loss events within a gauge.

- `GUILD_GOVERNANCE_PARAMETERS`: Permits the updating of governance parameters related to GUILD token delegations.

- **GUILD_SURPLUS_BUFFER_WITHDRAW:** Grants access to withdraw from a reserve of GUILD tokens.

- **CREDIT_GOVERNANCE_PARAMETERS:** Allows for the modification of governance parameters for CREDIT token delegations.

- **CREDIT_REBASE_PARAMETERS:** Grants the ability to adjust rebase parameters for CREDIT tokens, affecting token supply.

- `TIMELOCK_PROPOSER`: Permits proposing actions that will be executed after a delay via a timelock.

- `TIMELOCK_EXECUTOR`: Allows for the execution of actions that have passed their timelock delay.

- `TIMELOCK_CANCELLER`: Grants the ability to cancel proposed actions within a timelock.


### 4 . GuildGovernor.sol

**Inheritance Structure**
 The contract inherits from several OpenZeppelin contracts:

- `CoreRef`: A custom contract that likely manages core functionalities and references within the guild's ecosystem.
- `Governor`: The base governance module providing the core functionality of a governance system.
- `GovernorVotes`: An extension that integrates a voting token, in this case, an ERC20 token with additional vote tracking capabilities.
- `GovernorTimelockControl`: An extension that adds a timelock to governance actions, ensuring that there is a delay between when a proposal is approved and when it is executed.
- `GovernorSettings`: An extension that allows for the configuration of governance parameters such as voting delay, voting period, and proposal threshold.
- `GovernorCountingSimple`: A simple implementation of proposal vote counting.

**Quorum Management**
-  The contract has a private _quorum variable representing the minimum number of votes required for a proposal to be approved. It includes a setter function _setQuorum and an event QuorumUpdated for updating and tracking changes to the quorum.

**Governor-only Actions**
-  Certain functions (setVotingDelay, setVotingPeriod, setProposalThreshold, setQuorum) are restricted to addresses with the CoreRoles.GOVERNOR role, allowing only authorized governors to change critical governance settings.

**Guardian Role**
-  The contract introduces a guardian role (CoreRoles.GUARDIAN) with the ability to cancel proposals through the guardianCancel function, adding an additional layer of control in case of malicious proposals or emergencies.

**Overrides and Solidity Requirements**
-  The contract overrides several functions from the inherited modules to ensure that the custom logic and access controls are correctly integrated. These overrides include _cancel, _execute, _executor, proposalThreshold, state, and supportsInterface.

**Constructor**
-  The constructor initializes the contract with the core address, timelock address, token address, and initial settings for voting delay, voting period, proposal threshold, and quorum.

**Events**
-  The contract defines an event QuorumUpdated for logging changes to the quorum.

### 5 . GuildTimelockController.sol

**Inheritance**
-  It inherits from `OpenZeppelin's TimelockController and a custom CoreRef contract`. The TimelockController provides functionality for delayed execution of transactions, which is a common requirement for governance actions to allow for a period of review and potential intervention by stakeholders.

**Constructor**
-  The constructor takes two parameters: _core, which is the address of the Core contract that manages roles, and _minDelay, which is the minimum delay before a timelocked action can be executed. It initializes the CoreRef with the _core address and the TimelockController with the _minDelay and empty proposer and executor roles, as well as a zero address for the admin role.

**Access Control Override**
-  The contract overrides the hasRole function from OpenZeppelin's AccessControl to integrate with the Core contract's role management system. Instead of using the AccessControl's internal storage mapping for roles, it delegates the role checking to the Core contract.

**No-op Role Management**
-  The `_setRoleAdmin`, `_grantRole`, and `_revokeRole` functions are overridden to be no-operations (noops), as role management is handled externally by the Core contract. This means that the GuildTimelockController does not use the role management functionality of the AccessControl contract it inherits from.

**Purpose**
-  The contract is intended to provide a uniform access control mechanism across the ECG system, bypassing the standard OpenZeppelin access control in favor of the custom Core system.

**Security**
-  By centralizing role management in the Core contract, the GuildTimelockController aims to simplify and secure access control, assuming the Core contract itself is secure and well-managed.

**Customization**
-  The contract represents a customization of standard governance patterns to fit a particular system's requirements, showing how OpenZeppelin contracts can be extended and integrated with custom logic.


### 6 . LendingTermOffboarding.sol

**Events**

- `OffboardSupport`: Logs when a user supports the removal of a lending term.
- `Offboard`: Logs when a lending term is offboarded.
- `Cleanup`: Logs when a lending term is cleaned up after all loans are called.
- `QuorumUpdated`: Logs when the quorum required for offboarding is updated.

**Constants**
- `POLL_DURATION_BLOCKS`: The maximum duration for which a poll is considered valid, set to approximately 7 days based on a 13-second block time.

**State Variables**

- `quorum`: The number of votes required to offboard a lending term.
- `guildToken`: The address of the GUILD token contract.
- `psm`: The address of the PSM contract.
- `polls`: A mapping that tracks the total voting power for each removal poll.
- `userPollVotes`: A mapping that records the voting weight of each user in a poll.
- `lastPollBlock`: A mapping that stores the block number of the last poll for each term.
- `canOffboard`: A mapping indicating whether a term can be offboarded.
- `nOffboardingsInProgress`: A counter for the number of offboardings currently in progress.

**Constructor**

- Initializes the contract with references to the core contract, GUILD token, PSM, and sets the initial quorum.

**Functions**
- `setQuorum`:Allows the governor role to update the quorum.
- `proposeOffboard`:Starts a poll to offboard a lending term with an initial voting power of 1 wei.
- `supportOffboard`: Allows users to support an offboarding poll with their voting weight based on past votes.
- `offboard`: Offboards a lending term, preventing new loans and voting for the term, and may pause PSM redemptions if it's the first offboarding in progress.
- `cleanup`: Cleans up roles associated with an offboarded lending term, ensuring all loans are closed and the term is deprecated, and may unpause PSM redemptions if it's the last offboarding.

**Access Control and Modifiers**
- `onlyCoreRole`: Restricts certain functions to users with specific roles in the core contract.
- `whenNotPaused`: Ensures functions can only be called when the contract is not paused.

### 7 . LendingTermOnboarding.sol

**Governance Integration**
-  Inherits from GuildGovernor, indicating it is part of a governance system, and it overrides the propose function to prevent arbitrary governance actions, limiting it to onboarding lending terms.

**LendingTerm Creation**
-  The contract can create new LendingTerm instances from approved implementations, ensuring they meet specific criteria such as valid collateral tokens, interest rates, and other financial parameters.

**Onboarding Control**
-  It has a proposeOnboard function to propose the onboarding of a LendingTerm. It checks the term's creation by this factory, the timing of the last proposal, and whether the term is already active.

**Time Restrictions**
-  Enforces a minimum delay between onboarding proposals for each term to prevent proposal spamming and ensure governance integrity.

**Allowed Implementations**
-  Maintains a list of allowed LendingTerm implementations that can be updated by an authorized role, ensuring only vetted code can be used to create terms.

**Event Logging**
-  Emits events for changes in implementation status and term creation, providing transparency and traceability for governance actions.

**Immutable References**
-  Stores immutable references to key components of the ecosystem, such as guildToken, profitManager, auctionHouse, creditMinter, and creditToken, indicating its integration with the broader DeFi system.

**Role-Based Access Control**
-  Utilizes AccessControl for permission management, assigning roles to terms as part of the onboarding process.

**Proposal Calldata Generation**
-  The getOnboardProposeArgs function generates the necessary calldata for an onboarding proposal, which includes governance actions like adding the term as a gauge and granting specific roles.

**State Management**
-  Uses constants and mappings to manage the state of lending terms, tracking their proposal history, implementation approval, and creation timestamps.

### 8 . ProfitManager.sol

**Token References**
-  The contract holds references to the GUILD and CREDIT tokens, as well as a psm (presumably a Peg Stability Module for the CREDIT token).

**Profit and Loss Management**
-  The contract tracks profit indices for gauges (lending terms) and users, allowing for the distribution of profits to GUILD holders who vote for productive gauges.

**Surplus Buffer**
-  The contract maintains a global surplus buffer and individual term surplus buffers to absorb first-loss capital in case of bad debt. If losses exceed the surplus buffer, the creditMultiplier is decreased, effectively reducing the value of CREDIT tokens across the system.

**Credit Multiplier**
-  The creditMultiplier represents the value of CREDIT in the system. It can only decrease, meaning that CREDIT can only lose value over time when bad debt is created.

 **Minimum Borrow Amount**
-  The contract enforces a minimum borrow amount for CREDIT loans to ensure that liquidation costs do not exceed the minimum overcollateralization, which could result in bad debt.

 **Gauge Weight Tolerance**
-  The contract allows for a tolerance in gauge weights to facilitate the growth of the protocol and prevent deadlocks where no new borrows are allowed.

 **Profit Sharing Configuration**
-  The contract allows for the configuration of profit sharing between the surplus buffer, GUILD holders, CREDIT holders, and potentially another recipient. The configuration includes percentages for each party and the address of the other recipient if applicable.

**Events**
-  The contract emits various events for changes in the surplus buffer, CREDIT multiplier, profit sharing configuration, and when users claim rewards.

**Governance Functions**
-  The contract includes functions to set the minimum borrow amount, gauge weight tolerance, and profit sharing configuration. These functions are restricted to roles defined in CoreRoles.

**User Interaction**
-  Users can donate to the surplus buffer, claim rewards for a given gauge, and view pending rewards.

**Loss Handling**
-  When a loss is reported, the contract first depletes the term surplus buffer, then the global surplus buffer, and if necessary, reduces the creditMultiplier.

**Profit Distribution**
-  When a profit is reported, the contract distributes the profit according to the profit sharing configuration, updating the gauge profit index and distributing CREDIT to various parties.

### 9 . GuildVetoGovernor.sol

**Inheritance and Imports**

- Inherits from CoreRef, Governor, GovernorVotes, and indirectly from GovernorCountingSimple.
- Imports interfaces and contracts from OpenZeppelin, such as Governor, IGovernor, GovernorTimelockControl, GovernorVotes, IERC165, IVotes, TimelockController, CoreRef, and CoreRoles.

**Quorum Management**

- A private _quorum variable stores the minimum number of votes required for a veto to pass.
- The quorum function allows public access to check the current quorum.
- The setQuorum function allows updating the quorum, restricted to the GOVERNOR role from CoreRoles.
- An event QuorumUpdated is emitted whenever the quorum is changed.

**Timelock Management**

- The timelock public variable holds the address of the linked TimelockController.
- A mapping _timelockIds connects proposal IDs in the governor to action IDs in the timelock.
- The updateTimelock function allows updating the linked timelock, restricted to the GOVERNOR role.
- An event TimelockChange is emitted when the timelock is updated.

**Vote Counting**

- Defines a VoteType enum with options Against, For, and Abstain.
- A ProposalVote struct tracks votes against, for, and abstentions for each proposal, along with a mapping to track if an address has voted.
- Overrides _quorumReached and _voteSucceeded to accommodate the veto mechanism, where only against votes are counted, and a proposal is considered successful if it reaches quorum.

**Proposal Lifecycle**

- Overrides votingDelay to allow immediate voting on vetoes.
- Overrides votingPeriod to set a long duration, effectively using the timelock's timestamp to determine if the veto period is over.
- Overrides state to provide custom logic for determining the state of a proposal based on the timelock's state and quorum status.
- Overrides propose to prevent arbitrary proposals, enforcing that proposals can only be created through the createVeto function.

**Veto Mechanism**

- The createVeto function allows token holders to propose a veto against an action queued in the timelock.
- The executeVeto function allows for the execution of a successful veto, canceling the queued action in the timelock.
- The _getVetoCalls internal function constructs the proposal data for vetoes.

**Security and Access Control**

- Utilizes OpenZeppelin's role-based access control via CoreRoles to restrict sensitive functions like setQuorum and updateTimelock.
- Ensures that only against votes are allowed in veto proposals, preventing support for the queued action.

### 10 . ERC20Gauges.sol

**Gauge Weight Allocation**
-  Token holders can assign weights to gauges, influencing the distribution of resources. The contract tracks these allocations through mappings that relate users to gauges and their respective weights.

**State Management**
-  The contract maintains the state of each user's total allocated weight, each gauge's total weight, and the global total weight allocated to all live gauges.

**Gauge Types**
-  Gauges can be categorized by types, and the contract keeps track of the total weight allocated to each gauge type.

**Live and Deprecated Gauges**
-  The contract distinguishes between active (live) and inactive (deprecated) gauges. Users can allocate weight to live gauges and remove weight from both live and deprecated gauges.

**Gas DOS Attack Mitigation**
-  The maxGauges variable limits the number of gauges a user can allocate to, which helps prevent gas DOS attacks during token transfers.

**Weight Preservation**
-  The contract preserves the weight state for gauges and users even when a gauge is removed, allowing for the potential re-addition of a gauge without loss of historical weight.

**View Functions**
-  The contract provides several view functions that allow users to query information about gauges, user allocations, and unused weights.

 **Administrative Functions**
-  Internal functions are included for adding and removing gauges, setting the maximum number of gauges, and managing permissions for exceeding the max gauges limit.

**ERC20 Overrides**
-  The contract overrides certain ERC20 functions like _burn, transfer, and transferFrom to ensure that users have freed up enough weight before transferring or burning tokens.

**Events**
-  The contract emits events to signal changes in gauge weights, additions and removals of gauges, and updates to the maximum number of gauges and permissions.

### 11 . ERC20MultiVotes.sol

**Vote Calculation Logic**
- `Checkpoint struct`: Stores the block number (fromBlock) and the number of votes (votes) at that block.
- `_checkpoints`: A mapping that stores checkpoints for each account.
- `getVotes, getPastVotes, freeVotes`: Functions to get the current, past, and unallocated votes of an account, respectively.

**Admin Operations**
- `maxDelegates:` A variable that sets the maximum number of delegates per user.
- `canContractExceedMaxDelegates`: A mapping that allows certain contracts to exceed the maxDelegates limit.
- `_setMaxDelegates, _setContractExceedMaxDelegates`: Internal functions to update maxDelegates and canContractExceedMaxDelegates.

**Delegation Logic**
- `_delegatesVotesCount, userDelegatedVotes, _delegates`: Mappings and a set to keep track of delegated votes and delegates.
- `incrementDelegation, undelegate, delegate`: Functions to delegate, undelegate, and change delegates, respectively.
- `_incrementDelegation, _undelegate`: Internal functions that handle the logic for changing delegation amounts.
- `_writeCheckpoint`: Internal function to write a new checkpoint for an account when votes are delegated or undelegated.

**ERC20 Logic**
- `_burn, transfer, transferFrom`: Overrides to ensure votes are adjusted before token operations.
- `_decrementVotesUntilFree`: Internal function to free up votes for token operations.

**EIP-712 Logic**
- `DELEGATION_TYPEHASH`: EIP-712 type hash for delegation.
- `delegateBySig`: Function for off-chain signed delegation.

**Events**
- `MaxDelegatesUpdate, CanContractExceedMaxDelegatesUpdate`: Emitted when admin settings change.
- `Delegation, Undelegation, DelegateVotesChanged, DelegateChanged`: Emitted during delegation changes.

### 12 . ERC20RebaseDistributor.sol

**Events**
- `RebaseEnter`: Emitted when an account opts into rebasing.
- `RebaseExit`: Emitted when an account opts out of rebasing.
- `RebaseDistribution: Emitted when tokens are distributed to rebasing accounts.
- `RebaseReward`: Emitted when rebase rewards are realized for an account.

**Internal State**

- `RebasingState`: A struct to track whether an account is rebasing and the number of shares it holds.
- `rebasingState`: A mapping to store the RebasingState for each account.
- `totalRebasingShares`: The total number of rebasing shares across all accounts.
- `START_REBASING_SHARE_PRICE`: A constant representing the initial share price for rebasing accounts.
- `DISTRIBUTION_PERIOD`: A constant representing the period over which distributions are interpolated.
- `__rebasingSharePrice and __unmintedRebaseRewards`: Structs to manage interpolated values for share price and pending rebase rewards.

**Internal Utilities**

- `interpolatedValue`: Calculates the current value of an interpolated value over time.
- `updateTotalRebasingShares`: Updates the total number of rebasing shares when changes occur.
- `decreaseUnmintedRebaseRewards`: Decreases the amount of unminted rebase rewards when they are realized.
- `rebasingSharePrice`: Returns the current rebasing share price.
- `unmintedRebaseRewards`: Returns the current amount of unminted rebase rewards.
- `_balance2shares and _shares2balance`: Convert between token balances and shares.

**External API**

- `enterRebase`: Allows an account to opt into rebasing.
- `exitRebase`: Allows an account to opt out of rebasing and realize any pending rebase rewards.
- `distribute`: Burns tokens from the caller and distributes them proportionately to rebasing accounts.
- `isRebasing`: Checks if an account is rebasing.
- `rebasingSupply`: Returns the total number of tokens that are rebasing.
- `nonRebasingSupply`: Returns the total number of tokens that are not rebasing.
- `pendingDistributedSupply`: Returns the number of tokens that have been distributed but not yet realized due to interpolation.

**ERC20 Overrides**
- `balanceOf`: Overridden to include unminted rebase rewards in the balance calculation for rebasing accounts.
- `totalSupply`: Overridden to include unminted rebase rewards in the total supply.
- `targetTotalSupply`: Returns the target total supply after all interpolations are complete.
- `_burn, _mint, transfer, transferFrom`: Overridden to handle the rebase logic before and after token movements.

### 13 . CreditToken.sol

**Inheritance**

- `CoreRef`: A custom contract that likely manages core functionalities and access control.
- `ERC20Burnable`: An OpenZeppelin contract that allows token holders to destroy (burn) their tokens.
- `ERC20MultiVotes`: A custom contract that likely extends the voting capabilities of the token, allowing for multiple vote delegations.
- `ERC20RebaseDistributor`: A custom contract that likely manages token supply adjustments (rebases) and distributes the adjustments to token holders.

**Constructor**

- Initializes the contract with a name and symbol for the token and sets up the permit system for gasless approvals.

**Access-Controlled Functions**

- `mint`: Mints new tokens to a specified address. Restricted to addresses with the `CREDIT_MINTER` role.
- `setMaxDelegates`: Sets the maximum number of delegates an account can have. Restricted to addresses with the CREDIT_GOVERNANCE_PARAMETERS role.
- `setContractExceedMaxDelegates`: Allows or disallows an account to exceed the maximum number of delegates. Restricted to addresses with the CREDIT_GOVERNANCE_PARAMETERS role.
- `forceEnterRebase`: Forces an account to enter the rebase state. Restricted to addresses with the `CREDIT_REBASE_PARAMETERS` role.
- `forceExitRebase`: Forces an account to exit the rebase state. Restricted to addresses with the `CREDIT_REBASE_PARAMETERS` role.

**Override Functions**

- `_mint, _burn`: These internal functions are overridden to integrate the rebase and multi-vote functionality.
- `balanceOf, totalSupply`: These public view functions are overridden to return values adjusted by the rebase mechanism.
- `transfer, transferFrom`: These public functions are overridden to decrement votes and handle token transfers with rebase adjustments.

**Rebase Mechanism**

- The contract includes a rebase mechanism that adjusts the balance and supply of tokens to account for inflationary or deflationary pressures. This is managed by the `ERC20RebaseDistributor` contract.

**Voting Mechanism**

- The contract extends the ERC20 voting mechanism by allowing token holders to delegate their voting power to multiple delegates, managed by the `ERC20MultiVotes` contract.

### 14 . GuildToken.sol

**Inheritance**

- `CoreRef`: A custom contract that likely manages core functionalities and access control.
- `ERC20Burnable`: An OpenZeppelin contract that allows token holders to destroy (burn) their tokens.
- `ERC20Gauges`: A custom contract that likely manages gauge-related functionalities, such as voting weights for different lending terms.
- `ERC20MultiVotes`: A custom contract that likely allows token holders to delegate their voting power to multiple addresses.

**State Variables**

- `profitManager`: An address that references the ProfitManager contract, which likely manages the distribution of profits or rewards within the system.
- `transferable`: A boolean that indicates whether the tokens are transferable. It is initially set to false.
- `lastGaugeLoss`: A mapping that tracks the last timestamp when a loss occurred in a given gauge.
- `lastGaugeLossApplied`: A mapping that tracks the last timestamp when a loss was applied for a user in a given gauge.

**Constructor**

- Sets up the token with a name and symbol and initializes the profitManager address.

**Voting Management**

- Functions to set the maximum number of delegates and to allow certain contracts to exceed this limit.

**Gauge Management**

- Functions to add and remove gauges, set the maximum number of gauges, and allow certain addresses to exceed this limit.

**Loss Management**

- Functions to notify and apply losses in gauges, which affect the transferability and voting weight of tokens associated with the gauge that experienced the loss.

**Transferability:**

- A function to enable token transfers permanently, which can only be called by an address with the CoreRoles.GOVERNOR role.

**Events**

- Events for logging changes such as enabling transfers, updating the ProfitManager, and notifying or applying gauge losses.

**Mint/Burn**

- A function to mint new tokens, restricted to addresses with the CoreRoles.GUILD_MINTER role.

**Inheritance Reconciliation**

- Overrides _burn, transfer, and transferFrom functions to ensure that the custom logic for decrementing weights and votes is applied before performing the respective actions.

**Access Control**

- The contract uses role-based access control for certain functions, ensuring that only authorized addresses can perform sensitive operations.

**Modifiers and Internal Functions:**

- The contract includes various internal functions and modifiers to manage gauge weights, apply losses, and handle token transfers, ensuring that the contract's rules and restrictions are enforced.

### 15 . AuctionHouse.sol

**Auction Parameters**
 - The contract defines two immutable parameters, midPoint and auctionDuration, which dictate the auction's behavior. The midPoint represents the time before the auction's midpoint, after which the auction mechanism switches from offering increasing collateral to asking for decreasing debt. The auctionDuration sets the maximum length of an auction.

**Auction Events**
 - Two events, AuctionStart and AuctionEnd, are emitted to signal the start and end of an auction, respectively. These events log important information such as timestamps, loan IDs, collateral tokens, amounts, and debt recovered.

**Auction Storage**
 - The contract uses a mapping called auctions to keep track of all auctions, both past and active, indexed by a loanId. It also maintains a counter nAuctionsInProgress to track the number of ongoing auctions.

**Auction Lifecycle:**
 - The contract provides functions to start an auction (startAuction), get bid details (getBidDetail), place a bid (bid), and forgive a loan (forgive). These functions manage the auction's lifecycle from initiation to conclusion.

**Auction Logic**
 - The getBidDetail function calculates the bid details based on the auction's phase. In the first phase, the amount of collateral offered increases over time, while the debt asked remains constant. In the second phase, the full collateral is offered, but the debt asked decreases over time. If the auction duration is exceeded, the full collateral can be received for zero CREDIT.

**Bid Functionality**
 - The bid function allows participants to bid on an active auction. It requires the bidder to have approved CREDIT tokens on the associated LendingTerm contract. The function concludes the auction, updates the state, and notifies the LendingTerm contract of the auction result.

**Loan Forgiveness:**
 - The forgive function is used to mark a loan as a total loss, which might be necessary if the collateral assets are frozen or if an auction concludes without any bids, even at zero CREDIT.

**Access Control**
 - The contract includes checks to ensure that only authorized entities (e.g., those with the GAUGE_PNL_NOTIFIER role) can start auctions, and that auctions are only started for loans that have been called in the current block.

**Error Handling**
 - The contract uses require statements to validate conditions such as the existence of a loan, the uniqueness of an auction for a loan, and the appropriate phase of an auction. It also uses an assert statement to ensure that the auction's start time is always set correctly.


### 16 . LendingTerm.sol

**Loan Lifecycle Events**
-  The contract emits specific events for each stage of a loan's lifecycle, such as opening, calling, closing, adding collateral, and partial repayment.

**Structs**
-  It defines data structures for loans, signatures, and references to other protocol contracts, as well as parameters that govern the lending terms.

**Constants**
-  A YEAR constant is used to represent the number of seconds in a year for interest rate calculations.

**State Variables**
-  The contract maintains mappings for loans, their repayment timestamps, and the total issuance of CREDIT. It also holds references to other protocol contracts and lending term parameters.

**Initialization**
-  The contract is initialized with references to other protocol contracts and lending term parameters. The constructor prevents the implementation contract from being initialized.

**Getters**
-  Functions are provided to access contract references, parameters, loan details, and outstanding loan debts.

**Loan Operations**
-  The contract includes functions for borrowing, adding collateral, partial and full repayment, and calling loans.

**Interest and Debt Management**
-  It calculates loan debts, including interest, and checks for delays in partial repayments.

**Debt Ceiling**
-  The contract determines the maximum amount of debt that can be issued based on gauge allocations and other factors.

**Auction Interaction**
-  It interfaces with an AuctionHouse contract to manage the auctioning of collateral when a loan is called.

**Governance Actions**
-  Special functions are available for governance, such as forgiving a loan or updating the auction house address.

**Modifiers**
-  It uses OpenZeppelin's Pausable modifier to control function execution when the contract is paused.

**Core Functions**

- `borrow`: Initiates a new loan, issuing CREDIT tokens in exchange for collateral.
- `addCollateral`: Allows borrowers to increase the collateral backing their loan.
- `partialRepay`: Enables partial repayment of a loan's debt.
- `repay`: Closes a loan by repaying the full debt and returning the collateral.
- `call`: Triggers the auction of collateral under certain conditions, such as missed repayments.
- `forgive`: Marks a loan's debt as a loss, retaining the collateral in the contract.
- `onBid`: Handles the outcome of an auction, distributing collateral and managing debt repayment.

### 17 . SimplePSM .sol

**Contract Dependencies**
-  The contract imports several OpenZeppelin libraries for ERC20 token interactions and safe operations. It also imports custom contracts such as CoreRef, CoreRoles, LendingTerm, CreditToken, and ProfitManager.

**State Variables**

- `profitManager`: An immutable address of the ProfitManager contract, which manages the credit multiplier affecting the mint and redeem rates.
- `credit`: An immutable address of the CreditToken contract, representing the CREDIT token.
- `pegToken`: An immutable address of the peg token contract, against which CREDIT maintains its value.
- `pegTokenBalance`: A variable tracking the balance of the peg token within the PSM, excluding any donations.
- `decimalCorrection`: An immutable value used to correct for differences in decimal places between CREDIT and the peg token.
- `redemptionsPaused`: A boolean indicating whether redemptions are currently paused.
- `Constructor`: Sets up the contract by initializing the addresses of the core, ProfitManager, CreditToken, and peg token contracts. It also calculates the decimalCorrection based on the decimals of the peg token.

**Minting and Redemption Functions**

- `getMintAmountOut`: Calculates the amount of CREDIT that can be minted for a given amount of the peg token.
- `getRedeemAmountOut`: Calculates the amount of the peg token that can be redeemed for a given amount of CREDIT.
- `redeemableCredit`: Calculates the total amount of CREDIT that can be redeemed based on the current pegTokenBalance.
- `mint`: Allows users to mint CREDIT by depositing the peg token.
- `mintAndEnterRebase`: Similar to mint, but also enters the user into a rebase mechanism to earn a savings rate.
- `redeem`: Allows users to redeem CREDIT for the peg token.

**Governance Functions

- `setRedemptionsPaused`: A governance function that allows pausing or unpausing redemptions. It can only be called by an address with the GOVERNOR role.

**Events**

- `Redeem`: Emitted when CREDIT is redeemed for the peg token.
- `Mint`: Emitted when CREDIT is minted in exchange for the peg token.
- `RedemptionsPaused`: Emitted when the redemption pausability status changes.

**Modifiers and Access Control**

- The contract uses OpenZeppelin's Pausable modifier to control access to minting functions.
- The onlyCoreRole modifier restricts certain functions to addresses with specific roles, such as the GOVERNOR role.

### 18 . SurplusGuildMinter.sol

**Constants and Events**

- `MIN_STAKE`: The minimum amount of CREDIT tokens required to stake.
- `YEAR`: A constant representing the number of seconds in a year.
- Events such as `Stake`, `Unstake`, `GuildReward`, `MintRatioUpdate`, and `RewardRatioUpdate` are emitted for tracking actions and updates within the contract.

**State Variables*

- References to other contracts such as ProfitManager, CreditToken, GuildToken, and RateLimitedMinter.
- `mintRatio`: The ratio of GUILD tokens minted per CREDIT token staked.
- `rewardRatio`: The ratio of GUILD tokens rewarded per CREDIT token earned.
- `_stakes`: A mapping that stores the staking information for each user and term.

**Structs**

- `UserStake`: A struct that holds information about a user's stake, including timestamps, profit index, and the amounts of CREDIT and GUILD tokens staked.

**Constructor**

- Initializes the contract with references to other contracts and sets the initial mintRatio and rewardRatio.

**Staking and Unstaking**

- `stake()`: Allows users to stake CREDIT tokens for a specific term, mint GUILD tokens, and participate in gauge voting.
- `unstake()`: Allows users to unstake CREDIT tokens, stop participating in gauge voting, and burn the corresponding GUILD tokens.

**Rewards Management**

- `getRewards()`: Calculates and distributes rewards to users based on their staked GUILD tokens and updates their staking information. It also handles slashing if a loss has occurred.

**Ratio Management**

- `updateMintRatio()`: Updates the amount of GUILD tokens staked for a user based on the current mintRatio.
- `setMintRatio()`: A governor-only function to update the mintRatio.
- `setRewardRatio()`: A governor-only function to update the rewardRatio.

**Modifiers and Access Control**

- Inherits from CoreRef, which likely includes access control mechanisms and modifiers to restrict certain functions to specific roles like the governor.

**External and Public Functions**

- Functions like getUserStake() provide external access to contract state, while others like stake(), unstake(), and getRewards() are intended for users to interact with the contract.

**Security Considerations**

- The contract includes a whenNotPaused modifier on the `stake()` function, suggesting the presence of a pause mechanism for emergency stopping of staking.
- The contract uses SafeCastLib for safe type casting, which helps prevent `overflow` and `underflow` issues.

### 19 . RateLimitedMinter.sol

**Inheritance**

- Inherits from CoreRef, which likely provides core functionality and access control mechanisms.
- Inherits from RateLimitedV2, which provides the rate-limiting logic, including the buffer system that allows for controlled minting of tokens

**State Variables**

- `token`: An immutable address of the ERC20 token that this contract can mint.
- `role`: An immutable bytes32 identifier representing the role required to call the minting and buffer replenishing functions.

**Constructor**


The constructor takes several parameters to initialize the contract:
- `_core`: Address of the core smart contract, likely used for additional access control or logic.
- `_token`: Address of the ERC20 token that will be minted by this contract.
- `_role`: The role identifier required to mint and replenish the buffer.
- `_maxRateLimitPerSecond`: The maximum rate at which tokens can be minted per second, a cap set by governance.
- `_rateLimitPerSecond`: The initial rate limit per second for minting.
- `_bufferCap`: The maximum size of the buffer, which is a mechanism to allow for burst minting within limits.

**Minting Function (mint)**

- The mint function allows an address with the appropriate role to mint new tokens to a specified recipient (to) in a specified amount (amount).
- It is protected by the onlyCoreRole modifier, which checks that the caller has the correct role.
- It uses the whenNotPaused modifier to ensure that the function can only be called when the contract is not paused.
- The function first calls _depleteBuffer to check if there is enough allowance in the buffer to mint the requested amount and to update the buffer accordingly.
- It then calls the mint function of the ERC20 token contract to actually mint the tokens.

**Buffer Replenishment Function (replenishBuffer)**

- This function allows tokens to be added back into the buffer, which can be useful in scenarios where tokens are burned or need to be reissued.
- It is also protected by the onlyCoreRole modifier.
- The function calls `_replenishBuffer` to increase the buffer by the specified amount.

**Modifiers**

- `onlyCoreRole`: Ensures that only addresses with the specified role can call certain functions.
- `whenNotPaused`: Ensures that the function can only be executed when the contract is not paused.

### 20 . RateLimitedV2.sol

**Immutable Variables**

- `MAX_RATE_LIMIT_PER_SECOND`: The maximum rate limit per second that can be set by governance.

**State Variables**

- `rateLimitPerSecond`: The current rate limit per second.
- `bufferCap`: The maximum size of the buffer that can accumulate over time.
- `lastBufferUsedTime`: The last timestamp when the buffer was used.
- `bufferStored`: The amount of buffer available at the last usage time.

**Constructor**

- Initializes the contract with a maximum rate limit, starting rate limit, and buffer cap.
- Sets the lastBufferUsedTime to the current block timestamp.
- Validates and sets the initial rate limit and buffer cap.

**Governance Functions**

- `setRateLimitPerSecond(uint128 newRateLimitPerSecond)`: Allows governance to update the rate limit per second.
- `setBufferCap(uint128 newBufferCap)`: Allows governance to update the buffer cap.

**Buffer Management**

- `buffer()`: A public view function that calculates the current buffer based on the elapsed time and replenishes it at the rate of - rateLimitPerSecond up to bufferCap.
- `_depleteBuffer(uint256 amount)`: An internal function that decreases the buffer by a specified amount and updates the lastBufferUsedTime and bufferStored.
- `_replenishBuffer(uint256 amount)`: An internal function that increases the buffer by a specified amount if it is under the buffer cap.

**Internal Helper Functions**

- `_setRateLimitPerSecond(uint128 newRateLimitPerSecond)`: Updates the rate limit per second and emits an event.
- `_setBufferCap(uint128 newBufferCap)`: Updates the buffer cap and emits an event.
- `_updateBufferStored(uint128 newBufferCap)`: Updates the bufferStored based on the new buffer cap and the current buffer.

**Events**

- `BufferUsed`: Emitted when the buffer is used.
- `BufferReplenished`: Emitted when the buffer is replenished.
- `RateLimitPerSecondUpdate`: Emitted when the rate limit per second is updated.
- `BufferCapUpdate`: Emitted when the buffer cap is updated.


## Centralization Risks

1 .  Governance Centralization
- **Single Point of Failure:** The GOVERNOR role within Core.sol has extensive control over the protocol, including the ability to manage roles and permissions. This centralization creates a single point of failure, where the compromise of the GOVERNOR account could lead to a takeover of the protocol.
- **Veto Power:** The existence of a GuildVetoGovernor.sol contract suggests that certain parties may have the power to unilaterally veto governance decisions, which could lead to centralization of power if not distributed among a diverse group of stakeholders.

2 . Role Management Centralization
- **Role Assignment:** The process of assigning and revoking roles, as managed by CoreRoles.sol, is critical to the security of the protocol. If this process is not transparent and subject to community oversight, it could lead to centralization and abuse of power.

3 . Financial Centralization
- **Profit Distribution:** The ProfitManager.sol contract is responsible for distributing profits among stakeholders. Centralized control over this process could lead to unfair distribution and manipulation of funds.
- **Auction Control:** The AuctionHouse.sol contract, if not designed with adequate decentralization, could allow certain entities to have undue influence over auction outcomes.

4 . Token Supply Centralization
- **Minting Authority:** Contracts like SurplusGuildMinter.sol and RateLimitedMinter.sol that control token minting could centralize the power to influence the token supply if not governed by community consensus.


## Systematic Risks
1 . Governance System Vulnerabilities
- **Governance Attacks:** The protocol may be vulnerable to governance attacks such as proposal spamming, vote buying, or Sybil attacks, which could disrupt the decision-making process and lead to suboptimal outcomes for the protocol.

2 . Smart Contract Flaws
- **Contract Interdependencies:** The protocol's contracts are interdependent, meaning a vulnerability in one contract could have cascading effects on others, potentially leading to systemic failure.
- **Upgrade Path:** The lack of an explicit upgrade mechanism could result in the inability to address discovered vulnerabilities or adapt to new challenges, leading to technical debt and security risks.

3 . Financial Mechanism Complexity
- **Profit Calculation:** Complex algorithms for profit calculation and distribution in ProfitManager.sol must be error-free and resistant to exploitation to prevent loss of funds or unfair distribution.
- **Auction Mechanisms:** The AuctionHouse.sol contract must be designed to prevent manipulation tactics such as front-running or bid shading, which could undermine the integrity of the auction process.

4 . Token Economic Design
- **Token Stability:** The economic design of CreditToken.sol and GuildToken.sol, including mechanisms like rebasing in ERC20RebaseDistributor.sol, must be carefully managed to avoid destabilizing the token supply and maintain economic stability.

5 . Inter-Contract Communication
- **Contract Calls:** The protocol's functionality relies on calls between contracts, which must be secure against reentrancy attacks and other vulnerabilities that could arise from contract interactions.


## Learning and Insights 

**Understanding of Access Control Patterns**
 - By examining the Core.sol contract and its role-based access control,  learned how to implement and manage permissions within a smart contract system. This knowledge is crucial for developing secure applications that require different levels of access for various user types.

**Exposure to Governance Models**
- Studying the governance contracts within the protocol, such as GuildGovernor.sol, GuildTimelockController.sol, and GuildVetoGovernor.sol, provides insights into how decentralized decision-making can be structured and secured. This can improved the ability to design and code governance mechanisms that are resistant to common vulnerabilities.

**Financial Mechanism Design**
- Analyzing contracts like ProfitManager.sol and AuctionHouse.sol can deepen the  understanding of how to code complex financial operations within smart contracts. Learning to implement these mechanisms with transparency and fairness can enhance  skills in developing DeFi applications.

**Tokenomics and Incentive Alignment**
- The token contracts, including CreditToken.sol and GuildToken.sol, offer a practical case study in designing token economies. Understanding the balance between incentivizing user participation and maintaining token value is a valuable skill in the growing field of token engineering.

**Inter-Contract Communication**
- The interdependencies between contracts in the protocol highlight the importance of designing contracts that can securely interact with one another. Learning to code with an awareness of these interactions  improve  ability to build modular and composable systems.

**Upgradeability Considerations**
- The absence of an explicit upgrade path in the reviewed contracts underscores the importance of planning for future changes and improvements. Learning about upgrade patterns, such as proxy contracts, can enhance the  skill set in developing maintainable and adaptable code.

**Risk Management Techniques**
- The protocol's approach to managing systematic and market risks can teach  how to incorporate risk mitigation strategies into the code. This includes understanding the potential for governance attacks, financial exploitation, and economic model sustainability.



In summary, reviewing the Ethereum Credit Guild Protocol codebase can significantly contribute to the growth codebase skills by providing real-world  smart contract development challenges and solutions. It encourages a holistic approach to coding, combining technical proficiency with an understanding of governance, economics, and security in the context of blockchain applications.




## Recommendations


**Decentralization Strategies**
- Implement multi-signature or DAO structures for critical roles, especially the GOVERNOR, to distribute control and reduce the risk of unilateral decision-making.
- Introduce transparent processes for role management, ensuring that the community has oversight over role assignments and revocations.

**Governance Enhancements**
- Establish mechanisms to protect the governance process, such as minimum quorum requirements, stake locking periods, and anti-Sybil measures.
- Consider implementing a council or committee structure to provide additional layers of governance and reduce the impact of individual actors.

**Upgradeability and Maintenance**
- Develop an upgrade path for contracts, possibly through proxy patterns or other upgradeability frameworks, to ensure the protocol can evolve and address vulnerabilities.
- Regularly schedule audits and security reviews, particularly after major updates or before the launch of new features.

**Transparent Role Management**
-  Establish clear and transparent processes for role assignment and revocation, with community oversight to prevent abuse.

**Controlled Minting**
-  Introduce checks and balances for token minting processes, including community approval for significant changes to the token supply.

**Fair Financial Processes**
-  Ensure that profit distribution and auction mechanisms are transparent, auditable, and governed by community consensus to maintain fairness.

**Economic and Financial Safeguards**
- Conduct regular economic reviews and stress tests to ensure the tokenomics are sustainable and the financial mechanisms are robust against manipulation.
- Implement circuit breakers or pause functions in financial contracts to provide an emergency response capability in case of detected anomalies or attacks.

## Tips and Thoughts
- **Continuous Learning:** Stay updated with the latest security practices and DeFi developments to ensure the protocol remains secure and relevant.
- **Community Engagement:** Foster a strong community that can participate in governance and contribute to the protocol's security and development.
- **Transparency:** Maintain open communication channels and provide clear documentation to build trust and facilitate community oversight.
- **Risk Management:** Implement a comprehensive risk management framework that includes regular audits, bug bounties, and emergency response plans.

## Conclusion
The Ethereum Credit Guild presents an ambitious DeFi ecosystem with a multifaceted approach to credit, governance, and financial operations. While the protocol demonstrates a strong foundation, it must navigate the inherent risks associated with DeFi platforms, including centralization, governance vulnerabilities, financial manipulation, and tokenomic stability. Through diligent risk management, community engagement, and adherence to security best practices, the Ethereum Credit Guild can establish itself as a robust and trusted platform in the DeFi credit space.

### Time spent:
65 hours